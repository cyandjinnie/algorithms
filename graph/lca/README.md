#### Алгоритм ####
* Получаем на вход матрицу смежности, проходимся DFS'ом по дереву, посчитаем <br>
время входа и выхода из каждой вершины, рекуррентно заполним таблицу, которая <br>
в j-ой строке (начиная с 0) хранит предка через 2^j вершин для i-ой вершины <br>
=> размер таблицы n(сeil(logn)) (время выполнения предпосчета - O(nlogn)).
* Пусть current = a. При запросе LCA(a, b) в цикле i = ceil(logN) до 1 смотрим <br>
является ли ancestor[i][current] предком b (это просто делается т.к. мы <br>
посчитали время входа и выхода), если нет - переприсваиваем current = ancestor[i][current] <br>
Такими шагами мы поднимемся вверх от вершины а, как бы представляя расстояние от <br>
а до наименьшего общего предка с b в двоичном виде, откуда следует асимптотика O(logN)